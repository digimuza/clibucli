export interface DeepPartialArray<T> extends Array<DeepPartial<T>> {
}
export declare type DeepPartial<T> = T extends Function ? T : T extends Array<infer U> ? DeepPartialArray<U> : T extends object ? DeepPartialObject<T> : T | undefined;
export declare type DeepPartialObject<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
/**
 * Merging object from left to right
 *
 * @description
 * @param target value be preserved if possible.
 * Consider following
 *
 * array + obj = array
 * obj + array = obj
 * obj + obj = obj (recursively merged)
 * array + array = array (removes duplicates using Set)
 * (truthy plain value) + ob = (truthy plain value)
 * (truthy plain value) + undefined = (truthy plain value)
 * A(truthy plain value) + B(truthy plain value) = A(truthy plain value)
 *
 * Handles circular references
 * @returns {T}
 */
export declare function deepMergeLeft<T extends object>(target: T, ...sources: DeepPartialObject<T>[]): T;
/**
 * Merging object from right to left
 *
 * @description
 * @param target value will be replaced if possible.
 * Consider following
 *
 * array + obj = obj
 * obj + array = array
 * obj + obj = obj (recursively merged)
 * array + array = array (removes duplicates using Set)
 * (truthy plain value) + undefined = (truthy plain value)
 * A(truthy plain value) + B(truthy plain value) = B(truthy plain value)
 * Handles circular references
 * @returns {T}
 */
export declare function deepMergeRight<T extends object>(target: T, ...sources: DeepPartialObject<T>[]): T;
//# sourceMappingURL=deepMege.d.ts.map