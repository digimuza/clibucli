"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var purry_1 = require("./purry");
var type_1 = require("./type");
function sortBy() {
    return purry_1.purry(_sortBy, arguments);
}
exports.sortBy = sortBy;
// TODO this helpful function will be moved somewhere
function isObject(data) {
    return typeof data === 'object' && !Array.isArray(data);
}
// TODO this helpful function will be moved somewhere
function isArray(data) {
    return Array.isArray(data);
}
function _sortBy(array, fn) {
    var copied = __spreadArrays(array);
    return copied.sort(function (a, b) {
        var aa = fn(a);
        var bb = fn(b);
        /** Default comparison function */
        var defaultCompare = function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        };
        /** Easy way to swap order */
        var order = function (order, sortFn) {
            switch (order) {
                case 'asc':
                    return function (a, b) {
                        return sortFn(a, b);
                    };
                case 'desc':
                    return function (a, b) {
                        return sortFn(b, a);
                    };
            }
        };
        var sortComplex = function (aC, bC) {
            if (type_1.type(aC) !== type_1.type(bC)) {
                throw new Error("Can't compare two different types");
            }
            if (isObject(aC) && isObject(bC)) {
                var sortFn = order(aC.order || 'asc', bC.compare || defaultCompare);
                var orderScore = sortFn(aC.value, bC.value);
                return orderScore;
            }
            if (isObject(aC)) {
                throw new Error("Impossible error"); // Code should never throw this error .Using this only as typescript guard
            }
            if (isObject(bC)) {
                throw new Error("Impossible error"); // Code should never throw this error. Using this only as typescript guard
            }
            return order('asc', defaultCompare)(aC, bC);
        };
        if (isArray(aa) && isArray(bb)) {
            if (aa.length !== bb.length) {
                throw new Error("Critical sortBy error. Comparison properties should be static");
            }
            for (var _i = 0, _a = new Array(aa.length).fill(0).map(function (_, i) { return i; }); _i < _a.length; _i++) {
                var sIndex = _a[_i];
                var aaV = aa[sIndex];
                var bbV = bb[sIndex];
                if (type_1.type(aaV) !== type_1.type(bbV)) {
                    throw new Error("Can't compare two different types");
                }
                var result = sortComplex(aaV, bbV);
                if (result !== 0) {
                    return result;
                }
            }
        }
        if (type_1.type(aa) !== type_1.type(bb)) {
            throw new Error("Can't compare two different types");
        }
        if (isObject(aa) && isObject(bb)) {
            var sortFn = order(aa.order || 'asc', aa.compare || defaultCompare);
            var orderScore = sortFn(aa.value, bb.value);
            return orderScore;
        }
        if (isObject(aa)) {
            throw new Error("Impossible error"); // Code should never throw this error .Using this only as typescript guard
        }
        if (isObject(bb)) {
            throw new Error("Impossible error"); // Code should never throw this error. Using this only as typescript guard
        }
        return sortComplex(aa, bb);
    });
}
